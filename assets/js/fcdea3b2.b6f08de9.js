"use strict";(self.webpackChunkabap=self.webpackChunkabap||[]).push([[8931],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=r.createContext({}),c=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=c(e.components);return r.createElement(o.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(t),m=a,h=p["".concat(o,".").concat(m)]||p[m]||u[m]||i;return t?r.createElement(h,s(s({ref:n},d),{},{components:t})):r.createElement(h,s({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=p;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var c=2;c<i;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},7666:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=t(7462),a=(t(7294),t(3905));const i={title:"Vererbung und Schnittstellen",description:"",sidebar_position:50,tags:[]},s=void 0,l={unversionedId:"documentation/abap-objects/inheritance-and-interfaces",id:"documentation/abap-objects/inheritance-and-interfaces",title:"Vererbung und Schnittstellen",description:"",source:"@site/docs/documentation/abap-objects/inheritance-and-interfaces.md",sourceDirName:"documentation/abap-objects",slug:"/documentation/abap-objects/inheritance-and-interfaces",permalink:"/s4hana/documentation/abap-objects/inheritance-and-interfaces",draft:!1,editUrl:"https://github.com/appenmaier/s4hana/tree/main/docs/documentation/abap-objects/inheritance-and-interfaces.md",tags:[],version:"current",sidebarPosition:50,frontMatter:{title:"Vererbung und Schnittstellen",description:"",sidebar_position:50,tags:[]},sidebar:"documentationSidebar",previous:{title:"Klassenbasierte Ausnahmen",permalink:"/s4hana/documentation/abap-objects/exceptions"},next:{title:"ABAP CDS",permalink:"/s4hana/documentation/abap-cds/"}},o={},c=[{value:"Implementieren von Vererbung",id:"implementieren-von-vererbung",level:2},{value:"Polymorphie",id:"polymorphie",level:2},{value:"Abstrakte und finale Klassen und Methoden",id:"abstrakte-und-finale-klassen-und-methoden",level:2},{value:"Schnittstellen",id:"schnittstellen",level:2}],d={toc:c};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Bei der Modellierung von Klassen stellt man h\xe4ufig fest, dass sich einige Klassen der Struktur und dem Verhalten nach anderen Klassen \xe4hneln. In solchen F\xe4llen hat man die M\xf6glichkeit, die gemeinsamen Strukturen und Verhaltensweisen zu extrahieren und in einer\nallgemeineren Klasse unterzubringen. Dies f\xfchrt zu Spezialisierungs- bzw. Generalisierungshierarchien. Die Beziheung zwischen den speziellen Klassen (den sogenannte Unterklassen) sowie der allgemeineren Klasse (der sogenannten Oberklasse) wird als Vererbung\nbezeichnet."),(0,a.kt)("h2",{id:"implementieren-von-vererbung"},"Implementieren von Vererbung"),(0,a.kt)("p",null,"Vererbungen werden \xfcber den Zusatz ",(0,a.kt)("inlineCode",{parentName:"p"},"INHERITING FROM")," realisiert. Das \xdcberschreiben von Methoden erfolgt mit dem Zusatz ",(0,a.kt)("inlineCode",{parentName:"p"},"REDEFINITION"),", der Zugriff auf Elemente der Oberklasse erfolgt \xfcber den reservierten Namen ",(0,a.kt)("inlineCode",{parentName:"p"},"SUPER"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-abap",metastring:'title="CL_CAR.abap" showLineNumbers',title:'"CL_CAR.abap"',showLineNumbers:!0},"CLASS cl_car DEFINITION PUBLIC CREATE PUBLIC INHERITING FROM cl_vehicle.\n\n  PUBLIC SECTION.\n    DATA seats TYPE i READ-ONLY.\n\n    METHODS constructor\n      IMPORTING\n        make  TYPE string\n        model TYPE string\n        seats TYPE i\n      RAISING\n        cx_initial_parameter.\n\n    METHODS to_string REDEFINITION.\n\n  PROTECTED SECTION.\n\n  PRIVATE SECTION.\n\nENDCLASS.\n\nCLASS cl_car IMPLEMENTATION.\n\n  METHOD constructor.\n    super->constructor( make = make model = model ).\n    me->seats = seats.\n  ENDMETHOD.\n\n  METHOD to_string.\n    string = super->to_string( ) && | { seats }|.\n  ENDMETHOD.\nENDCLASS.\n")),(0,a.kt)("h2",{id:"polymorphie"},"Polymorphie"),(0,a.kt)("p",null,"Unter Polymorphie (griechisch f\xfcr Vielgestaltigkeit) versteht man in der Programmierung die Tatsache, dass eine Referenzvariable zur Laufzeit durch Typumwandlung auf Objekte unterschiedlicher Klassen zeigen kann und dass dadurch ein Methodenaufruf\nunterschiedliche Ergebnisse erzielen kann. Man spricht in diesem Zusammenhang auch vom statischen Datentyp einer Variablen (der zur Designzeit festgelegt wird) und vom dynamischen Datentyp (der zur Laufzeit zugewiesen wird). Die Typumwandlung von der\nabgeleiteten Unterklasse zur Oberklasse bezeichnet man als ",(0,a.kt)("em",{parentName:"p"},"Upcast"),", die R\xfcckumwandlung als ",(0,a.kt)("em",{parentName:"p"},"Downcast"),". Der Downcast erfolgt dabei \xfcber den Operator ",(0,a.kt)("inlineCode",{parentName:"p"},"CAST"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-abap",metastring:'title="CL_MAIN.abap" showLineNumbers',title:'"CL_MAIN.abap"',showLineNumbers:!0},"CLASS cl_main DEFINITION PUBLIC FINAL CREATE PUBLIC.\n  PUBLIC SECTION.\n    INTERFACES if_oo_adt_classrun.\n  PROTECTED SECTION.\n  PRIVATE SECTION.\nENDCLASS.\n\nCLASS cl_main IMPLEMENTATION.\n\n  METHOD if_oo_adt_classrun~main.\n\n    DATA vehicle TYPE REF TO cl_vehicle.\n    DATA car TYPE REF TO cl_car.\n\n    car = NEW cl_car( make = 'Porsche' model = '911' seats = 2 ).\n\n    \" Upcast\n    vehicle = car.\n\n    \" Downcast without type check\n    TRY.\n      car = CAST #( vehicle ).\n    CATCH cx_sy_move_cast_error INTO DATA(e).\n      out->write( e->get_text( ) ).\n    ENDTRY.\n\n    \" Downcast with type check\n    IF vehicle IS INSTANCE OF cl_car.\n      car = CAST #( vehicle ) .\n    ENDIF.\n\n  ENDMETHOD.\n\nENDCLASS.\n")),(0,a.kt)("admonition",{title:"Hinweis",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Zur Typpr\xfcfung beim Downcast kann der Ausdruck ",(0,a.kt)("inlineCode",{parentName:"p"},"IS INSTANCE OF")," verwendet werden.")),(0,a.kt)("h2",{id:"abstrakte-und-finale-klassen-und-methoden"},"Abstrakte und finale Klassen und Methoden"),(0,a.kt)("p",null,"Das Schl\xfcsselwort ",(0,a.kt)("inlineCode",{parentName:"p"},"ABSTRACT")," erm\xf6glicht die Definition von abstrakten Klassen und Methoden, das Schl\xfcsselwort ",(0,a.kt)("inlineCode",{parentName:"p"},"FINAL")," die Definition von finalen Klassen und Methoden:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"abstrakte Klassen k\xf6nnen nicht instanziiert werden"),(0,a.kt)("li",{parentName:"ul"},"abstrakte Methoden besitzen keine Implementierung und m\xfcssen von den abgeleiteten Klassen implementiert werden."),(0,a.kt)("li",{parentName:"ul"},"finale Klassen k\xf6nnen nicht abgeleitet werden"),(0,a.kt)("li",{parentName:"ul"},"finale Methode k\xf6nnen nicht \xfcberschrieben werden")),(0,a.kt)("h2",{id:"schnittstellen"},"Schnittstellen"),(0,a.kt)("p",null,"Schnittstellen (Interfaces) sind im Prinzip abstrakte Klassen, die ausschlie\xdflich abstrakte Methoden besitzen. Durch Schnittstellen wird sichergestellt, dass Klassen bestimmte Methoden bereitstellen und dass verschiedene Klassen miteinander kommunizieren k\xf6nnen.\nSie werden mit dem Schl\xfcsselwort ",(0,a.kt)("inlineCode",{parentName:"p"},"INTERFACE")," definiert, in der implementierenden Klasse mit dem Schl\xfcsselwort ",(0,a.kt)("inlineCode",{parentName:"p"},"INTERFACES")," bekanntgegeben und k\xf6nnen analog zu Klassen abgeleitet werden."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-abap",metastring:'title="IF_PARTNER.abap" showLineNumbers',title:'"IF_PARTNER.abap"',showLineNumbers:!0},"INTERFACE if_partner.\n\n  METHODS to_string.\n\nENDINTERFACE.\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-abap",metastring:'title="CL_RENTAL.abap" showLineNumbers',title:'"CL_RENTAL.abap"',showLineNumbers:!0},"CLASS cl_rental DEFINITION PUBLIC CREATE PUBLIC.\n\n  PUBLIC SECTION.\n    INTERFACES if_partner.\n\n    DATA vehicles TYPE TABLE OF cl_vehicle READ-ONLY.\n\n    METHODS add_vehicle\n      IMPORTING\n        vehicle TYPE REF TO cl_vehicle.\n\n  PROTECTED SECTION.\n\n  PRIVATE SECTION.\n\nENDCLASS.\n\nCLASS cl_rental IMPLEMENTATION.\n\n  METHOD add_partner.\n    APPEND vehicle TO vehicles.\n  ENDMETHOD.\n\n  METHOD if_partner~to_string.\n    LOOP AT vehicles INTO DATA(vehicle).\n      string &&= vehicle->to_string( ).\n    ENDLOOP.\n  ENDMETHOD.\n\nENDCLASS.\n")))}u.isMDXComponent=!0}}]);