"use strict";(self.webpackChunkabap=self.webpackChunkabap||[]).push([[9964],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>b});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=i.createContext({}),l=function(e){var n=i.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=l(e.components);return i.createElement(o.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},c=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),c=l(t),b=a,m=c["".concat(o,".").concat(b)]||c[b]||d[b]||r;return t?i.createElement(m,s(s({ref:n},p),{},{components:t})):i.createElement(m,s({ref:n},p))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,s=new Array(r);s[0]=c;var u={};for(var o in n)hasOwnProperty.call(n,o)&&(u[o]=n[o]);u.originalType=e,u.mdxType="string"==typeof e?e:a,s[1]=u;for(var l=2;l<r;l++)s[l]=t[l];return i.createElement.apply(null,s)}return i.createElement.apply(null,t)}c.displayName="MDXCreateElement"},3927:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>u,toc:()=>l});var i=t(7462),a=(t(7294),t(3905));const r={title:"Modularisierung mit Funktionsbausteinen",description:"",sidebar_position:90,tags:[]},s=void 0,u={unversionedId:"abap/documentation/function-modules",id:"abap/documentation/function-modules",title:"Modularisierung mit Funktionsbausteinen",description:"",source:"@site/docs/abap/documentation/function-modules.md",sourceDirName:"abap/documentation",slug:"/abap/documentation/function-modules",permalink:"/s4hana/docs/abap/documentation/function-modules",draft:!1,editUrl:"https://github.com/appenmaier/s4hana/tree/main/docs/abap/documentation/function-modules.md",tags:[],version:"current",sidebarPosition:90,frontMatter:{title:"Modularisierung mit Funktionsbausteinen",description:"",sidebar_position:90,tags:[]},sidebar:"abapSidebar",previous:{title:"Klassische ABAP-Programme",permalink:"/s4hana/docs/abap/documentation/reports"},next:{title:"Strukturen",permalink:"/s4hana/docs/abap/documentation/structures"}},o={},l=[{value:"Funktionsgruppen",id:"funktionsgruppen",level:2},{value:"Definition von Funktionsbausteinen",id:"definition-von-funktionsbausteinen",level:2},{value:"Aufruf von Funktionsbausteinen",id:"aufruf-von-funktionsbausteinen",level:2},{value:"Klassische Ausnahmen",id:"klassische-ausnahmen",level:2}],p={toc:l};function d(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Mit Hilfe von Modularisierungseinheiten kann Quellcode gekapselt werden. Vorteile von Modularisierung sind neben der Wiederverwendbarkeit die erh\xf6hte \xdcbersichtlichkeit, sowie die verbesserte Wartbarkeit des Codes. ABAP kennt zwei globale\nModularisierungseinheiten: Funktionsbausteine in Funktionsgruppen und Methoden in globale Klassen."),(0,a.kt)("p",null,"Parameter dienen dem Datenaustausch zwischen der aufrufenden FUnktion und der Modularisierungseinheit. Die Menge aller Parameter wird als Schnittstelle (bei Funktionsbausteinen) bzw. als Signatur (bei Methoden) bezeichnet."),(0,a.kt)("h2",{id:"funktionsgruppen"},"Funktionsgruppen"),(0,a.kt)("p",null,"Funktionsgruppen sind Sammlungen von Funktionsbausteinen, die verwandte Funktionalit\xe4ten besitzen bzw. auf den selben Daten operieren. Sie besitzen neben Funktionsbausteinen auch Datenobjekte (die alle Funktionsbausteine der Funktionsgruppe verwenden k\xf6nnen).\nWird ein Funktionsbaustein aufgerufen, wird die gesamte Funktionsgruppe geladen und die Funktionsgruppe sowie die dazugeh\xf6rigen globalen Daten bleiben bis zur Beendigung des aufrufenden Programms erhalten."),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/47243617/194825944-685f0ff8-aca4-424c-b176-3469fe6d22c5.png",alt:"image"})),(0,a.kt)("h2",{id:"definition-von-funktionsbausteinen"},"Definition von Funktionsbausteinen"),(0,a.kt)("p",null,"Funktionsbausteine verf\xfcgen \xfcber Eigenschaften (z.B. Kurzbeschreibung), lokale Datenobjekte bzw. lokale Typdefinitionen sowie \xfcber eine Schnittstelle. Die Schnittstelle eines Funktionsbausteins besteht aus Import-, Export- und Changing-Parametern sowie den\nAusnahmen."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-abap"},"FUNCTION calculate_power\n  IMPORTING\n    i_base     TYPE i\n    i_exponent TYPE i DEFAULT 2\n  EXPORTING\n    e_result   TYPE i.\n\n  e_result = i_base ** i_exponent.\n\nENDFUNCTION.\n")),(0,a.kt)("admonition",{title:"Hinweis",type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Der Zusatz ",(0,a.kt)("inlineCode",{parentName:"p"},"OPTIONAL")," bewirkt, dass ein Import Parameter beim Aufruf des Funktionsbausteins nicht angegeben werden muss, mit dem Zusatz ",(0,a.kt)("inlineCode",{parentName:"p"},"DEFAULT")," kann ein Import-Parameter mit einem Wert vorbelegt werden.")),(0,a.kt)("h2",{id:"aufruf-von-funktionsbausteinen"},"Aufruf von Funktionsbausteinen"),(0,a.kt)("p",null,"Funktionsbausteine werden mit der Anweisung ",(0,a.kt)("inlineCode",{parentName:"p"},"CALL FUNCTION")," aufgerufen. Der EXPORTING-Block enth\xe4lt dabei die Import-Parameter des Funktionsbausteins, der IMPORTING-Block die Export-Parameter."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-abap"},"DATA result TYPE i.\n\nCALL FUNCTION 'CALCULATE_POWER'\n  EXPORTING\n    i_base     = 5\n    i_exponent = 3\n  IMPORTING\n    e_result   = result.\n")),(0,a.kt)("h2",{id:"klassische-ausnahmen"},"Klassische Ausnahmen"),(0,a.kt)("p",null,"Innerhalb eines Funktionsbausteins kann mit der Anweisung ",(0,a.kt)("inlineCode",{parentName:"p"},"RAISE")," eine Ausnahme ausgel\xf6st werden. Die Verarbeitung des Funktionsbausteins wird dabei nach Ausl\xf6sen der Ausnahme abgebrochen."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-abap"},"FUNCTION calculate_power\n  IMPORTING\n    i_base     TYPE i\n    i_exponent TYPE i DEFAULT 2\n  EXPORTING\n    e_result   TYPE i\n  EXCEPTIONS\n    negative_exponent.\n\n  IF i_exponent < 0.\n    RAISE negative_exponent.\n  ENDIF.\n  \n  e_result = i_base ** i_exponent.\n\nENDFUNCTION.\n")),(0,a.kt)("p",null,"Durch die Angabe eines EXCEPTIONS-Blockes k\xf6nnen beim Aufruf eines Funktionsbausteins m\xf6gliche Ausnahmen abgefangen werden. Der im EXCEPTIONS-Block angegebene Returncode wird im Ausnahmefall in das Systemfeld ",(0,a.kt)("inlineCode",{parentName:"p"},"SY-SUBRC")," geschrieben und erm\xf6glicht so eine\nspezifische Fehlerbehandlung."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-abap"},"DATA result TYPE i.\n\nCALL FUNCTION 'CALCULATE_POWER'\n  EXPORTING\n    i_base            = 5\n    i_exponent        = 3\n  IMPORTING\n    e_result          = result\n  EXCEPTIONS\n    negative_exponent = 1\n    OTHERS            = 2.\nCASE sy-subrc.\n  WHEN 1.\n    WRITE 'negative_exponent'.\n  WHEN 2.\n    WRITE 'others'.\nENDCASE.\n")))}d.isMDXComponent=!0}}]);